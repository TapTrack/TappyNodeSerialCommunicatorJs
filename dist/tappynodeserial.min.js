!function(n){"function"==typeof define&&define.amd?define(["serialport"],n):module.exports=n(require("serialport"))}(function(t){return NodeSerialCommunicator=function(n){var e=this;if(null!=n&&"object"==typeof n.serial)this.serial=n.serial;else{if(null==n||"string"!=typeof n.path)throw new Error("Must either specify a path or a constructed serial port");this.serial=new t(n.path,{baudRate:115200,autoOpen:!1})}this.isConnecting=!1,this.hasAttached=!1,this.disconnectImmediately=!1,this.disconnectCb=function(){},this.dataReceivedCallback=function(n){},this.errorCallback=function(n){},this.readCallback=function(n){e.dataReceivedCallback(new Uint8Array(n))}},NodeSerialCommunicator.prototype={attachReadWrite:function(){var n=this;n.hasAttached||(n.hasAttached=!0,n.serial.on("data",n.readCallback))},connect:function(e){var t=this;t.isConnecting||t.isConnected()||(t.isConnecting=!0,t.serial.open(function(n){t.isConnecting=!1,t.attachReadWrite(),"function"==typeof e&&e(n),t.disconnectImmediately&&t.disconnectUnsafe()}))},flush:function(n){},isConnected:function(){return this.serial.isOpen},disconnectUnsafe:function(){var e=this;if(e.isConnecting)throw"Connection still in the process of being established";e.isConnected()&&e.serial.close(function(n){"function"==typeof e.disconnectCb&&e.disconnectCb(n)})},disconnect:function(n){var e=this;e.disconnectImmediately=!0,"function"==typeof n&&(e.disconnectCb=n),!e.isConnecting&&e.isConnected()&&e.disconnectUnsafe()},send:function(t){var i=this;i.serial.write(Buffer.from(t),function(n){var e;n&&"function"==typeof i.errorCallback&&(e={buffer:t,nodeError:n},i.errorCallback(e))})},setDataCallback:function(n){this.dataReceivedCallback=n},setErrorCallback:function(n){this.errorCallback=n}},NodeSerialCommunicator});